# ═══════════════════════════════════════════════════════════════
# EFFICIENCY COMPONENTS
# ═══════════════════════════════════════════════════════════════
# 
# Total efficiency: ε_total = ε_acc × ε_reco × ε_strip × ε_trig × ε_sel
#
# Calculation method:
# - ε_acc: From MC truth (generator level → detector acceptance)
# - ε_reco: COMBINED with stripping for now (placeholder = 0)
# - ε_strip: From data-driven stripping campaign (placeholder = 0)  
# - ε_trig: From phase space MC (KpKm sample)
# - ε_sel: From MC (offline selection on reconstructed)
#
# NOTE: Full efficiency study will be done separately later!
#       For now, we focus on RATIOS (many efficiencies cancel)
# ═══════════════════════════════════════════════════════════════

[stripping_efficiency]
# From data-driven stripping campaign
# TO BE PROVIDED by user
# Format: {state}.{year} = {value = X, error = Y}

[stripping_efficiency.jpsi]
"2016" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2017" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2018" = {value = 0.0, error = 0.0}  # PLACEHOLDER

[stripping_efficiency.etac]
"2016" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2017" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2018" = {value = 0.0, error = 0.0}  # PLACEHOLDER

[stripping_efficiency.chic0]
"2016" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2017" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2018" = {value = 0.0, error = 0.0}  # PLACEHOLDER

[stripping_efficiency.chic1]
"2016" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2017" = {value = 0.0, error = 0.0}  # PLACEHOLDER
"2018" = {value = 0.0, error = 0.0}  # PLACEHOLDER

[reconstruction_efficiency]
# Combined with stripping for now
# Will be separated in future detailed efficiency study
comment = """
Reconstruction efficiency calculation requires:
- Matching reconstructed to truth in MC
- Understanding detector acceptance effects
- Tracking efficiency corrections

For now: COMBINED with stripping, set to 0 (placeholder)
This is OK because we work with RATIOS (cancels for same detector)
"""

[trigger_efficiency]
# Calculate from phase space MC (KpKm sample)
# Method: Apply trigger cuts to phase space → measure pass rate
source = "phase_space_mc"
comment = """
Trigger efficiency from KpKm (phase space) MC:
- Apply trigger decision requirements
- No truth-matching needed (data-like sample)
- Measure: ε_trig = N_pass_trigger / N_total

This is more reliable than using signal MC (which may not have
trigger branches, or may not model trigger correctly)
"""

[efficiency_strategy]
notes = """
For this DRAFT analysis:

1. ACCEPTANCE (ε_acc):
   ✓ Calculate from truth-matched MC
   ✓ Generator level → detector acceptance
   ✓ State-dependent (different kinematics)

2. RECONSTRUCTION + STRIPPING (ε_reco×strip):
   ⚠ Set to ZERO (placeholder)
   ⚠ Will study properly later
   ⚠ In ratios, may cancel if similar

3. TRIGGER (ε_trig):
   ✓ Calculate from phase space MC (KpKm)
   ✓ Apply trigger decisions to phase space
   ✓ Measure pass rate

4. SELECTION (ε_sel):
   ✓ Calculate from MC after optimization
   ✓ Apply optimized cuts to truth-matched MC
   ✓ State-dependent

KEY POINT: We measure RATIOS, so many efficiencies cancel!
This allows us to proceed with placeholders for some components.
"""